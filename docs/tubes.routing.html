<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>tubes.routing : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            tubes API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code>tubes.routing</code> <small>module documentation</small></h1>

        <span id="partOf">
          Part of <code><a class="code" href="tubes.html">tubes</a></code>
          
          
        </span>
      </div>

      <div class="extrasDocstring">
        
      </div>

      <div class="moduleDocstring">
        <div><p>A <a href="tubes.routing.Router.html"><code>Router</code></a> receives 
items with addressing information and dispatches them to an appropriate 
output, stripping the addressing information off.</p>
<p>Use like so:</p>
<pre class="literalblock">
   from tubes.routing import Router, Routed, to

   aRouter = Router(int)

   evens, evenFount = aRouter.newRoute()
   odds, oddFount = aRouter.newRoute()

   @tube
   class EvenOdd(object):
       outputType = Routed(int)
       def received(self, item):
           if (item % 2) == 0:
               yield to(evens, item)
           else:
               yield to(odds, item)

   numbers.flowTo(aRouter)
</pre>
<p>This creates a fount in evenFount and oddFount, which each have an 
outputType of "int".</p>
<p>Why do this rather than just having <code>EvenOdd</code> just call 
methods directly based on whether a number is even or odd?</p>
<p>By using a <a href="tubes.routing.Router.html"><code>Router</code></a>, 
flow control relationships are automatically preserved by the same 
mechanism that tubes usually use.  The distinct drains of evenFount and 
oddFount can both be independently paused, and the pause state will be 
propagated to the "numbers" fount.  If you want to send on 
outputs to multiple drains which may have complex flow-control 
interrelationships, you can't do that by calling the <code>receive</code> 
method directly since any one of those methods might reentrantly pause 
you.</p><table class="fieldTable"></table></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id8">
  
  <tr class="class">
    
    <td>Class</td>
    <td><a class="code" href="tubes.routing.Routed.html">Routed</a></td>
    <td><span>A <a href="tubes.routing.Routed.html"><code>Routed</code></a> is an 
interface describing another interface that has been wrapped in a 
<code>to</code>.  As such, it is an incomplete implementation of <a href="https://zope.org/zope.interface.interfaces.IInterface.html"><code>IInterface</code></a>.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a class="code" href="tubes.routing.html#to">to</a></td>
    <td><span>Construct a provider of <a href="tubes.routing.Routed.html"><code>Routed</code></a><code>(providedBy(where))</code>.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a class="code" href="tubes.routing.Router.html">Router</a></td>
    <td><span>A drain with multiple founts that consumes <a href="tubes.routing.Routed.html"><code>Routed</code></a><code>(IX)</code> 
from its input and produces <code>IX</code> to its outputs.</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><a class="code" href="tubes.routing._To.html">_To</a></td>
    <td><span>An object destined for a specific destination.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="function">
  <a name="tubes.routing.to">
    
  </a>
  <a name="to">
    
  </a>
  <div class="functionHeader">
    
    def
    to(where, what):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Construct a provider of <a href="tubes.routing.Routed.html"><code>Routed</code></a><code>(providedBy(where))</code>.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">where</td><td>A fount returned from <a href="tubes.routing.Router.html#newRoute"><code>Router.newRoute</code></a>.
This must be <i>exactly</i> the return value of <a href="tubes.routing.Router.html#newRoute"><code>Router.newRoute</code></a>,
as it is compared by object identity and not by any feature of <a href="tubes.itube.IFount.html"><code>IFount</code></a>.</td></tr><tr><td></td><td class="fieldArg">what</td><td>the value to deliver.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a <a href="tubes.routing.Routed.html"><code>Routed</code></a> object.</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><a href="tubes.routing.html"><code>tubes.routing</code></a></td></tr></table></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for tubes, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> at 2015-05-06 17:59:08.
      </address>

    </div>
  </body>
</html>