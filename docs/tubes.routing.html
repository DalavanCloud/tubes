<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>tubes.routing : API documentation</title>

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            tubes API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code>tubes.routing</code> <small>module documentation</small></h1>

        <span id="partOf">
          Part of <code><a data-type="Package" class="code" href="tubes.html">tubes</a></code>
          
          
        </span>
      </div>

      <div class="extrasDocstring">
        
      </div>

      <div class="moduleDocstring">
        <div><p>A <a href="tubes.routing.Router.html"><code>Router</code></a> receives 
items with addressing information and dispatches them to an appropriate 
output, stripping the addressing information off.</p>
<p>Use like so:</p>
<pre class="literalblock">
   from tubes.tube import receiver, series
   from tubes.routing import Router, to

   aRouter = Router()
   evens = aRouter.newRoute()
   odds = aRouter.newRoute()

   @receiver()
   def evenOdd(item):
       if (item % 2) == 0:
           yield to(evens, item)
       else:
           yield to(odds, item)

   numbers.flowTo(series(evenOdd, aRouter.drain))
</pre>
<p>Assuming <code>numbers</code> is a fount of counting integers, this 
creates two founts: <code>evens</code> and <code>odds</code>, whose outputs
are even and odd integers, respectively. Note that <code>evenOdd</code> 
also uses <code>evens</code> and <code>odds</code> as <i>addresses</i>; the
first argument to <a href="tubes.routing.html#to"><code>to</code></a> says 
<i>where</i> the value will go.</p>
<p>Why do this rather than just having <code>evenOdd</code> just call 
methods directly based on whether a number is even or odd?</p>
<p>By using a <a href="tubes.routing.Router.html"><code>Router</code></a>, 
flow control relationships are automatically preserved by the same 
mechanism that tubes usually use.  The distinct drains of 
<code>evens</code> and <code>odds</code> can both independently pause their
founts, and the pause state will be propagated to the "numbers" 
fount.  If you want to send on outputs to multiple drains which may have 
complex flow-control interrelationships, you can't do that by calling the 
<code>receive</code> method directly since any one of those methods might 
reentrantly pause its fount.</p><table class="fieldTable"></table></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id19">
  
  <tr class="class">
    
    <td>Class</td>
    <td><a data-type="Class" class="code" href="tubes.routing.Routed.html">Routed</a></td>
    <td><span>A <a href="tubes.routing.Routed.html"><code>Routed</code></a> is a 
specification describing another specification that has been wrapped in a 
<code>to</code>.  As such, it is an incomplete implementation of <a href="https://zope.org/zope.interface.interfaces.ISpecification.html"><code>ISpecification</code></a>.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a data-type="Function" class="code" href="tubes.routing.html#to">to</a></td>
    <td><span>Construct a provider of <a href="tubes.routing.Routed.html"><code>Routed</code></a><code>(providedBy(where))</code>.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a data-type="Class" class="code" href="tubes.routing.Router.html">Router</a></td>
    <td><span>A drain with multiple founts that consumes <a href="tubes.routing.Routed.html"><code>Routed</code></a><code>(IX)</code> 
from its input and produces <code>IX</code> to its outputs.</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><a data-type="Class" class="code" href="tubes.routing._To.html">_To</a></td>
    <td><span>An object destined for a specific destination.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction">
  
  <a name="tubes.routing.to">
    
  </a>
  <a name="to">
    
  </a>
  <div class="functionHeader">
    
    def
    to(where, what):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Construct a provider of <a href="tubes.routing.Routed.html"><code>Routed</code></a><code>(providedBy(where))</code>.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">where</td><td>A fount returned from <a href="tubes.routing.Router.html#newRoute"><code>Router.newRoute</code></a>.
This must be <i>exactly</i> the return value of <a href="tubes.routing.Router.html#newRoute"><code>Router.newRoute</code></a>,
as it is compared by object identity and not by any feature of <a href="tubes.itube.IFount.html"><code>IFount</code></a>.</td></tr><tr><td></td><td class="fieldArg">what</td><td>the value to deliver.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a <a href="tubes.routing.Routed.html"><code>Routed</code></a> object.</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><a href="tubes.routing.html"><code>tubes.routing</code></a></td></tr></table></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for tubes, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> at 2015-12-07 07:46:54.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>